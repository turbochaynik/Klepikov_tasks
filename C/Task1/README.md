Я выполнял вариант 4 - Чат 2. Реализованы клиент и сервер были на языке С. Сначала распишу клиент:
Глобальные определения и переменные
BUFFER_SIZE задаёт максимальный размер буфера для передачи данных.
sock – глобальная переменная, которая будет хранить файловый дескриптор сокета клиента.
client_name – массив для хранения ника (имени) клиента. Его размер равен 50 символам.
Функция для приёма сообщений: receive_messages
Она создает отдельный поток, который постоянно слушает входящие сообщения от сервера. Подробности работы:
Выделяется локальный массив buffer размером BUFFER_SIZE.
В бесконечном цикле с помощью memset буфер очищается.
Функция recv пытается принять данные из сокета sock (используя сокет, созданный в main).
Если recv возвращает число байт меньше или равное нулю, это означает, что соединение разорвано или произошла ошибка – цикл завершается.
Полученная строка завершается символом '\0', чтобы можно было корректно её выводить.
Выводится сообщение с префиксом [SERVER]: и приглашение для ввода команды.
fflush(stdout) гарантирует, что вывод будет немедленно отображён на экране.
В функции main сначала происходит проверка аргументов запуска:
Программа ожидает, что при запуске будет передано три параметра: IP-адрес сервера, порт и никнейм. Если параметров меньше, выводится сообщение о правильном использовании и программа завершается. Из аргументов командной строки копируется третий аргумент (argv[3]) в глобальный массив client_name с учётом безопасности (ограничение по размеру и явное завершение строки). Объявляется переменная server_addr типа struct sockaddr_in, которая будет хранить адрес сервера, а также локальный буфер для обмена сообщениями. Далее создается сокет, и настраивается его структура. Далее функция connect инициирует соединение с сервером по адресу, указанному в server_addr. В случае неудачи выводится сообщение об ошибке. Создаётся строка name_with_delim, в которую записывается имя клиента, завершающееся символом перевода строки \n.
Этот разделитель гарантирует, что сервер сможет правильно определить конец имени, даже если далее будут отправляться другие команды.
Затем эта строка отправляется на сервер с помощью send. Создается новый поток, который запускает функцию receive_messages. Этот поток будет параллельно принимать и выводить сообщения, поступающие от сервера, не блокируя основной поток ввода команд. Выводится сообщение о том, что соединение успешно установлено, и приглашение для ввода команд. Основной цикл отправки команд:
Выводится приглашение "Command:".
Функция fgets читает строку с клавиатуры (из стандартного ввода) в буфер.
Функция strcspn используется для нахождения позиции символа новой строки и замены его на '\0', что гарантирует корректное окончание строки. Отправка данных через функцию send. Если отправка не удалась – выводится ошибка и цикл завершается.
Если введённая команда равна символу "\" (как сигнал для завершения работы), цикл также прерывается. Закрывается сокет с помощью close(sock).
Поток приёма сообщений завершается с помощью pthread_cancel и затем ожидается его завершение с помощью pthread_join.
Программа возвращает 0, что означает корректное завершение работы.


Сервер:
PORT – номер порта, на котором сервер слушает входящие соединения.
MAX_CLIENTS – максимальное количество одновременно обслуживаемых клиентов.
MAX_NAME_LEN – максимальная длина ника (имени) клиента.
Структура client хранит информацию о подключённом клиенте:

socket – файловый дескриптор сокета, по которому идет связь с клиентом.
name – ник клиента, который передается сразу после подключения.
Cтруктура clientinfo используется для передачи параметров в поток, который обслуживает клиента. Поля:

socket – сокет клиента.
index – индекс, по которому клиент будет сохранён в глобальном массиве clients.
Client clients[MAX_CLIENTS];
Массив клиентов. Для каждого нового подключения сервер сохраняет информацию о клиенте (сокет и ник).
Переменные, используемые для реализации логики "калькулятора":

global_increment – глобальное значение, которое может изменяться командой +<число>.
stored_values и stored_sockets – временные массивы для хранения чисел и сокетов клиентов при обработке арифметической операции.
stored_count – счетчик, сколько чисел уже получено для текущей операции.
int server_running = 1;
Флаг, управляющий основным циклом сервера. При его сбросе (устанавливается 0) сервер завершает работу.
pthread_mutex_t lock;
Мьютекс для синхронизации доступа к общим ресурсам (например, к массиву клиентов, глобальным переменным и списку приватных сообщений).
int server_sock;
Файловый дескриптор серверного сокета.
client_threads – массив потоков для обслуживания клиентов.
client_count – количество активных клиентов.
input_thread – поток, который читает команды с терминала (например, для отправки приватных сообщений или завершения работы сервера).
Функция пробуждения accept() – wakeup_accept. Если функция accept() блокируется (например, при завершении работы сервера), это подключение прерывает блокировку, позволяя выйти из основного цикла. 
Функция завершения сервера – shutdown_server. При получении сигнала (например, SIGINT, SIGTSTP или SIGTERM) сервер:
Выводит сообщение о завершении работы.
Устанавливает server_running в 0, что сигнализирует о прекращении работы основного цикла.
Вызывает shutdown для серверного сокета, разрывая все соединения.
Закрывает серверный сокет.
Вызывает wakeup_accept() для пробуждения блокирующего вызова accept().
Функция обслуживания клиента – handle_client. В потоке клиенту передается структура ClientInfo, из которой извлекаются сокет и индекс клиента. Память освобождается сразу после извлечения данных. Клиент сразу после подключения отправляет своё имя, завершающееся символом перевода строки \n. Функция recv считывает данные, затем strtok извлекает строку до первого символа новой строки. Если имя не получено, соединение закрывается. С помощью мьютекса сервер синхронно записывает полученное имя в соответствующий элемент массива clients. Далее выводится сообщение о регистрации клиента. В цикле сервер ждет команды от клиента, очищая буфер перед каждым чтением. Если recv возвращает 0 или отрицательное значение, цикл завершается (соединение закрыто или произошла ошибка).
Обработка команд:
Если команда начинается с '+', сервер изменяет глобальное значение global_increment (значение берется после знака '+') и отправляет подтверждение клиенту.
Если команда – '?', сервер возвращает текущее значение global_increment.
Если команда – '\', это сигнал завершения работы с клиентом.
Иначе сервер считает, что получено число для операции калькулятора. Число сохраняется во временный массив, а также сохраняется сокет клиента.
Если получено два числа, сервер складывает их, прибавляет глобальное значение и отправляет результат обоим клиентам, участвующим в операции. Если пока получено только одно число, сервер уведомляет клиента о том, что ждет второе число.
После выхода из цикла сокет закрывается, и поток завершается.
Функция обработки команд с терминала – server_input_listener. Этот поток позволяет администратору сервера вводить команды в консоли. Он работает параллельно с обработчиками клиентов.
Функция main сервера. Объявляются переменные для хранения адреса сервера и клиента, а также переменная для размера структуры адреса. Устанавливаются обработчики сигналов (SIGINT, SIGTSTP, SIGTERM), чтобы при получении этих сигналов вызывалась функция shutdown_server для корректного завершения работы. Инициализируется мьютекс, который будет использоваться для синхронизации доступа к общим ресурсам. Создается серверный сокет. В случае ошибки выводится сообщение, и программа завершается. Заполняется структура server_addr:
sin_family – адресное семейство (IPv4).
sin_addr.s_addr – принимает значение INADDR_ANY, что позволяет серверу принимать подключения с любых интерфейсов.
sin_port – номер порта, преобразованный в сетевой порядок байт.
Функция bind связывает серверный сокет с указанным IP-адресом и портом. Если привязка не удалась, выводится ошибка.
Функция listen переводит сокет в режим прослушивания. Максимальное количество ожидающих соединений ограничено значением MAX_CLIENTS.
Создается поток для обработки команд с терминала (административных команд).
Основной цикл ожидания клиентов:
В цикле вызывается accept, который ожидает новое входящее соединение.
Для каждого нового подключения выделяется память для структуры ClientInfo.
Если сервер завершает работу или возникает ошибка, выделенная память освобождается.
С мьютексом проверяется, что число клиентов не превышает MAX_CLIENTS.
В структуру ClientInfo записывается индекс нового клиента, а его сокет сохраняется в массиве clients.
Затем создаётся новый поток, который будет выполнять функцию handle_client для данного подключения.
Если создать поток не удалось, сокет закрывается, а память освобождается.
После выхода из цикла (например, при завершении работы сервера) поток, обрабатывающий ввод с терминала, отменяется и ожидается его завершение. Ожидается завершение всех потоков, обслуживающих клиентов. Уничтожается мьютекс, освобождая системные ресурсы.
Перед завершением работы сервера происходит обход массива names, куда с помощью strdup копировались имена, и для каждого элемента вызывается free, чтобы избежать утечек памяти.
