task2.1
я создал переменные типа double:  e - эпсилон, x - вводимое значение, x1 и x2 - элементы итеративной формулы. После ввода значения x с клавиатуры программа совершает цикл, в котором находится новое значение xi, до момента, когда найденное значение разности x(i-1) и xi (в переменных x1 и x2 соответственно) будет меньше наперед заданной e. вывод значения x выполняется по критериям, описанным в условии задачи.

task2.2.1
в этой программе я создал три переменные типа double:
	x - точка, в которой нужно найти значение функции
	a -  переменная, в которую записывается каждый последующий коэффициент многочлена
	s - значение функции
после считывания точки x цикл, работающий пока вводятся коэффициенты, умножает уже имеющееся значение функции на x, таким образом, повышая степень многочлена, а потом прибавляет новый коэффициент. 

task2.2.2
в этой программе я действую аналогично. Только в цикле кроме вычисления значения функции в точке я вычисляю и значение производной: я беру предыдущее значение функции в точке, после чего прибавляю к нему крайнее значение производной в точке

task2.3
в программе находятся две функции, которые находят n-й член последовательности Фибоначчи: итеративная и рекурсивная
в итеративной версии задаются переменные a и b типа int. Дальше действует простой цикл, который создает в b новый элемент ряда Фибоначчи, а в a записывает предыдущий.
в рекурсивной версии не нужны никакие переменные, их роль играют сами значения функций, вызываемые рекурсивно.
Чтобы пронаблюдать разницу во времени вычисления достаточно просто ввести n больше 40. Уже становится видно, насколько долго думает рекурсивная функция.

task2.4
в программе у меня реализована одна большая функция. В ней у меня заданы переменные:
sign - используется как знак числа
result - здесь хранится целая часть числа
fraction - здесь хранится множитель для части числа после запятой
	в начале функции я прохожусь по строке, пропуская все пробелы перед числом (если таковые есть). Далее если встречаю знак, то записываю его в переменную sign (-1 если встречен минус и 1 если встречен + или нет никакого знака).
После этого я прохожу по целой части числа: считываю строку посимвольно и добавляю в переменную result если этот символ - цифра. 
Если в строке встречается точка, то сначала я разделю множитель fraction на 10, а потом прибавлю к результату эту цифру, умноженную на множитель. 
После этого если встречается e, то создается новый флаг exp_sign: 
он будет сигнализировать, какой знак идет после e. Если встречается минус/плюс, то все записывается по аналогии с sign.
после этого задается еще одна переменная exponent - в нее записывается часть числа после e. Делается это стандартно, как и в result.
После записи e нужно изменить само число, записанное в result. Для этого создается дополнительная переменная power, которая exponent раз умножится на 10.
Далее если у экспоненты знак +, то число, записанное в result умножится на power, и разделится, если знак - соответственно.
после этого возвращаем числу знак, сохраненный в переменной sign и функция завершена.

task2.5
в этой программе для сохранения слова будет использоваться структура:
	первый элемент word - ссылка на слово
	второй элемент elem - ссылка на слеудющее слово
для записи слова в структуру сначала загружаем слово в буфер посимвольно. после этого вызывается функция addElem:
	тут создается новый элемент структуры, длина слова подбирается при помощщи calloc. после этого новое слово посимвольно копируется из буфера. 
После этого созданную структуру соединяем с остальным списком: прохожусь по нему до момента, пока ссылка на следующее слово не будет содержать NULL. 
После того как все слова сохранены в списке, сохраняем последнее слово списка в переменную last. Так же создаем переменную prev типа структуры.
Если элемент списка совпадает с последним словом, сохраненным в lastWord, этот элемент списка пропускается, ссылка с предыдущего слова переходит сразу на следующее, а сама структура, выделенная память под нее очищаются. 
После этого снова проходим по всему списку, каждое слово выводится на экран.

task2.6
в этой программе работаем так же со структурой. В этой структуре три элемента:
	key - число в вершине
	left - ссылка на левую ветвь дерева
	right - ссылка на правую ветвь дерева
программа начинается с ввода знака (+, -, ?) в переменную op и числа в digit. дальше ориентируясь на знак есть три варианта:
	если знак +, то то сначала вызываем функцию search, отвечающую за поиск элемента в дереве. Ее алгоритм очевиден, пока мы не пройдемся до листа дерева сравниваем наше значение со значением в вершине. Если оно отличается, то спускаемся либо вправо, либо влево. Если не отличается, то выходим из функции. Если элемент не найден,то вызываем функцию добавления элемента addElem.
В ней мы сначала вызываем небольшую функцию createTree, которая создаст лист дерева, в котором уже будем хранить наше значение. После этого мы спускаемся до момента, когда уже надо вставлять наш лист и соответственно вставляем его. 
Далее, если у нас был встречен знак -, мы, соответственно, сначала вызываем функцию search, и если она нашла наше число, вызываем функцию deleteElem.
В ней мы аккуратно спускаемся по дереву к элементу, который надо удалить, запоминая адрес предыдущей вершины в переменную prev. Далее рассматривается три случая:
	первый случай, когда нам нужно удалить лист, то есть у него нет ни ссылки влево, ни ссылки вправо. Тогда мы просто удаляем элемент, а предыдущей вершине (если такая есть) присваиваем в ссылку значение NULL. 
Если у элемента, который надо удалить, только одна ветвь есть, то мы просто должны ее пропустить. Мы от предыдущей вершины ведем ссылку с ветви current'а, а сам current освобождаем.
Если у текущей вершины есть ссылки и вправо и влево, то мы действуем по другому. Мы спускаемся в правую ветвь и при помощи функции findMin находим минимальный элемент. После этого возвращаемся в нашу вершину и присваиваем ей значение, найденное в той функции. Так как нужно удалить лист, который мы скопировали вместо удаленного значения, рекурсивно вызываем функцию удаления элемента для правой ветви.
Вариант с ? является тривиальным, тк для его выполнения просто выполняется вышеупомянутая функция search.

task2.7
тут пояснение тривиально. операции вычитания и деления нацело добавляются в функции expr и add соответственно к сложению и произведению. Для добавления возведения в степень добавим эту операцию в функцию mult, которая будет рекурсивно вычислять значения возведения в степень, таким образом, вычисление возведений в степень будет выполняться справа налево.
